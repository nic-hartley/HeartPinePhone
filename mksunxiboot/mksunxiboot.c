// SPDX-License-Identifier: GPL-2.0+
/*
 * (C) Copyright 2007-2011
 * Allwinner Technology Co., Ltd. <www.allwinnertech.com>
 * Tom Cubie <tangliang@allwinnertech.com>
 *
 * a simple tool to generate bootable image for sunxi platform.
 * 
 * Ripped out from p-boot/src/{tools/mksunxiboot.c,arch/arm/include/asm/arch-sunxi/spl.h}
 * Combined to be just one file
 */
#include <fcntl.h>
#include <stdio.h>
#include <unistd.h>
#include <stdlib.h>
#include <stdint.h>
#include <stddef.h>
#include <endian.h>
#include <string.h>
#include <errno.h>
#include <sys/types.h>
#include <sys/stat.h>

#define BOOT0_MAGIC		"eGON.BT0"
#define SPL_SIGNATURE		"SPL" /* marks "sunxi" SPL header */
#define SPL_MAJOR_BITS		3
#define SPL_MINOR_BITS		5
#define SPL_VERSION(maj, min)						\
	((((maj) & ((1U << SPL_MAJOR_BITS) - 1)) << SPL_MINOR_BITS) | \
	((min) & ((1U << SPL_MINOR_BITS) - 1)))

#define SPL_HEADER_VERSION	SPL_VERSION(0, 2)

#define SPL_ENV_HEADER_VERSION	SPL_VERSION(0, 1)
#define SPL_DT_HEADER_VERSION	SPL_VERSION(0, 2)
#define SPL_DRAM_HEADER_VERSION	SPL_VERSION(0, 3)

#define SPL_ADDR		CONFIG_SUNXI_SRAM_ADDRESS

/* The low 8-bits of the 'boot_media' field in the SPL header */
#define SUNXI_BOOTED_FROM_MMC0	0
#define SUNXI_BOOTED_FROM_NAND	1
#define SUNXI_BOOTED_FROM_MMC2	2
#define SUNXI_BOOTED_FROM_SPI	3
#define SUNXI_BOOTED_FROM_MMC0_HIGH	0x10
#define SUNXI_BOOTED_FROM_MMC2_HIGH	0x12

/* boot head definition from sun4i boot code */
struct boot_file_head {
	uint32_t b_instruction;	/* one intruction jumping to real code */
	uint8_t magic[8];	/* ="eGON.BT0" or "eGON.BT1", not C-style str */
	uint32_t check_sum;	/* generated by PC */
	uint32_t length;	/* generated by PC */
	/*
	 * We use a simplified header, only filling in what is needed
	 * by the boot ROM. To be compatible with Allwinner tools we
	 * would need to implement the proper fields here instead of
	 * padding.
	 *
	 * Actually we want the ability to recognize our "sunxi" variant
	 * of the SPL. To do so, let's place a special signature into the
	 * "pub_head_size" field. We can reasonably expect Allwinner's
	 * boot0 to always have the upper 16 bits of this set to 0 (after
	 * all the value shouldn't be larger than the limit imposed by
	 * SRAM size).
	 * If the signature is present (at 0x14), then we know it's safe
	 * to use the remaining 8 bytes (at 0x18) for our own purposes.
	 * (E.g. sunxi-tools "fel" utility can pass information there.)
	 */
	union {
		uint32_t pub_head_size;
		uint8_t spl_signature[4];
	};
	uint32_t fel_script_address;	/* since v0.1, set by sunxi-fel */
	/*
	 * If the fel_uEnv_length member below is set to a non-zero value,
	 * it specifies the size (byte count) of data at fel_script_address.
	 * At the same time this indicates that the data is in uEnv.txt
	 * compatible format, ready to be imported via "env import -t".
	 */
	uint32_t fel_uEnv_length;	/* since v0.1, set by sunxi-fel */
	/*
	 * Offset of an ASCIIZ string (relative to the SPL header), which
	 * contains the default device tree name (CONFIG_DEFAULT_DEVICE_TREE).
	 * This is optional and may be set to NULL. Is intended to be used
	 * by flash programming tools for providing nice informative messages
	 * to the users.
	 */
	uint32_t dt_name_offset;	/* since v0.2, set by mksunxiboot */
	uint32_t dram_size;		/* in MiB, since v0.3, set by SPL */
	uint32_t boot_media;		/* written here by the boot ROM */
	/* A padding area (may be used for storing text strings) */
	uint32_t string_pool[13];	/* since v0.2, filled by mksunxiboot */
	/* The header must be a multiple of 32 bytes (for VBAR alignment) */
};

/* Compile time check to assure proper alignment of structure */
typedef char boot_file_head_not_multiple_of_32[1 - 2*(sizeof(struct boot_file_head) % 32)];

#define is_boot0_magic(addr)	(memcmp((void *)addr, BOOT0_MAGIC, 8) == 0)


#define STAMP_VALUE                     0x5F0A6C39

/* check sum functon from sun4i boot code */
int gen_check_sum(struct boot_file_head *head_p)
{
	uint32_t length;
	uint32_t *buf;
	uint32_t loop;
	uint32_t i;
	uint32_t sum;

	length = le32toh(head_p->length);
	if ((length & 0x3) != 0)	/* must 4-byte-aligned */
		return -1;
	buf = (uint32_t *)head_p;
	head_p->check_sum = htole32(STAMP_VALUE);	/* fill stamp */
	loop = length >> 2;

	/* calculate the sum */
	for (i = 0, sum = 0; i < loop; i++)
		sum += le32toh(buf[i]);

	/* write back check sum */
	head_p->check_sum = htole32(sum);

	return 0;
}

#define ALIGN(x, a) __ALIGN_MASK((x), (typeof(x))(a)-1)
#define __ALIGN_MASK(x, mask) (((x)+(mask))&~(mask))

#define SUNXI_SRAM_SIZE 0x8000	/* SoC with smaller size are limited before */
#define SRAM_LOAD_MAX_SIZE (SUNXI_SRAM_SIZE - sizeof(struct boot_file_head))

/*
 * BROM (at least on A10 and A20) requires NAND-images to be explicitly aligned
 * to a multiple of 8K, and rejects the image otherwise. MMC-images are fine
 * with 512B blocks. To cater for both, align to the largest of the two.
 */
#define BLOCK_SIZE 0x2000

struct boot_img {
	struct boot_file_head header;
	char code[SRAM_LOAD_MAX_SIZE];
	char pad[BLOCK_SIZE];
};

int main(int argc, char *argv[])
{
	int fd_in, fd_out;
	struct boot_img img;
	unsigned file_size;
	int count;
	char *tool_name = argv[0];
	char *default_dt = NULL;

	/* a sanity check */
	if ((sizeof(img.header) % 32) != 0) {
		fprintf(stderr, "ERROR: the SPL header must be a multiple ");
		fprintf(stderr, "of 32 bytes.\n");
		return EXIT_FAILURE;
	}

	/* process optional command line switches */
	while (argc >= 2 && argv[1][0] == '-') {
		if (strcmp(argv[1], "--default-dt") == 0) {
			if (argc >= 3) {
				default_dt = argv[2];
				argv += 2;
				argc -= 2;
				continue;
			}
			fprintf(stderr, "ERROR: no --default-dt arg\n");
			return EXIT_FAILURE;
		} else {
			fprintf(stderr, "ERROR: bad option '%s'\n", argv[1]);
			return EXIT_FAILURE;
		}
	}

	if (argc < 3) {
		printf("This program converts an input binary file to a sunxi bootable image.\n");
		printf("\nUsage: %s [options] input_file output_file\n",
		       tool_name);
		printf("Where [options] may be:\n");
		printf("  --default-dt arg         - 'arg' is the default device tree name\n");
		printf("                             (CONFIG_DEFAULT_DEVICE_TREE).\n");
		return EXIT_FAILURE;
	}

	fd_in = open(argv[1], O_RDONLY);
	if (fd_in < 0) {
		perror("Open input file");
		return EXIT_FAILURE;
	}

	memset(&img, 0, sizeof(img));

	/* get input file size */
	file_size = lseek(fd_in, 0, SEEK_END);

	if (file_size > SRAM_LOAD_MAX_SIZE) {
		fprintf(stderr, "ERROR: File too large!\n");
		return EXIT_FAILURE;
	}

	fd_out = open(argv[2], O_WRONLY | O_CREAT | O_TRUNC, 0666);
	if (fd_out < 0) {
		perror("Open output file");
		return EXIT_FAILURE;
	}

	/* read file to buffer to calculate checksum */
	lseek(fd_in, 0, SEEK_SET);
	count = read(fd_in, img.code, file_size);
	if (count != file_size) {
		perror("Reading input image");
		return EXIT_FAILURE;
	}

	/* fill the header */
	img.header.b_instruction =	/* b instruction */
		0xEA000000 |	/* jump to the first instr after the header */
		((sizeof(struct boot_file_head) / sizeof(int) - 2)
		 & 0x00FFFFFF);
	memcpy(img.header.magic, BOOT0_MAGIC, 8);	/* no '0' termination */
	img.header.length =
		ALIGN(file_size + sizeof(struct boot_file_head), BLOCK_SIZE);
	img.header.b_instruction = htole32(img.header.b_instruction);
	img.header.length = htole32(img.header.length);

	memcpy(img.header.spl_signature, SPL_SIGNATURE, 3); /* "sunxi" marker */
	img.header.spl_signature[3] = SPL_HEADER_VERSION;

	if (default_dt) {
		if (strlen(default_dt) + 1 <= sizeof(img.header.string_pool)) {
			strcpy((char *)img.header.string_pool, default_dt);
			img.header.dt_name_offset =
				htole32(offsetof(struct boot_file_head,
						     string_pool));
		} else {
			printf("WARNING: The SPL header is too small\n");
			printf("         and has no space to store the dt name.\n");
		}
	}

	if (gen_check_sum(&img.header) < 0) {
		printf("ERROR: Checksum failed\n");
		return EXIT_FAILURE;
	}

	count = write(fd_out, &img, le32toh(img.header.length));
	if (count != le32toh(img.header.length)) {
		perror("Writing output");
		return EXIT_FAILURE;
	}

	close(fd_in);
	close(fd_out);

	return EXIT_SUCCESS;
}
